<?php

/**
 * @file
 * An entity, stripped of its Agent's asking powers.
 */

namespace TestRig\Models;

use TestRig\Services\Database;
use TestRig\Services\Generate;
use TestRig\Services\Maths;

/**
 * @class
 * Entity.
 */
class Entity extends AbstractDBObject
{
    // Supplier pool.
    protected $pool = [];

    // Database table we save to.
    protected $table = "entity";
    // Default arguments.
    private $defaultArguments = array(
        // Try to match order in schema.sql here, but we need tier first so
        // case 'label': works below.
        'tiers' => [1],
        'label' => '<DEFAULT>',
        'is_sourcing' => false,

        'mean_ack_time' => 5,
        'mean_answer_time' => 5,
        'mean_routing_time' => 5,
        'self_time_ratio' => 1,

        // How many suppliers, on average, will an ask branch to?
        'mean_extra_suppliers' => 0,
        // How many suppliers does the entity have in its preferred pool?
        'mean_supplier_pool_size' => 0,
        'supplier_pool' => [],

        'probability_no_ack' => 0,
        'probability_no_answer' => 0,
        'probability_pick_from_pool' => 0,
    );

    /**
     * Overrides ::create().
     *
     * Create and save new entity; handle (recipe) arguments into individual
     * entity properties; deal with tiers in other table.
     *
     * @param array $arguments
     *   Any arguments to be saved alongside autogenerated name.
     */
    public function create($arguments = array())
    {
        // Create data suitable for database.
        $this->data = array(
            'name' => isset($arguments['name']) ? $arguments['name'] :
                Generate::getEntityName(),
        );

        // Turn arguments into entity properties,, based on default arguments.
        foreach ($this->defaultArguments as $argumentName => $argumentData) {
            // Permit overriding by incoming arguments.
            if (isset($arguments[$argumentName])) {
                $argumentData = $arguments[$argumentName];
            }

            // Different callbacks based on argumentName.
            switch ($argumentName) {

            // Population label: verbatim, but default means use tier.
            case 'label':
                if ($argumentData === '<DEFAULT>') {
                    $argumentData = 'Tier ' . $this->data['tiers'][0];
                }
                $this->data['population'] = $argumentData;
                break;

            // Tier: verbatim number.
            // Self-time ratio multiplier: verbatim number.
            // Supplier pool: verbatim array.
            case 'tiers':
            case 'self_time_ratio':
            case 'supplier_pool':
                $this->data[$argumentName] = $argumentData;
                break;

            // Is this a sourcing agent? Randomized based on incoming
            // probability, but from then on a boolean.
            case 'is_sourcing':
                $this->data[$argumentName] = $argumentData;
                if (isset($arguments['probability_is_sourcing'])) {
                    $this->data[$argumentName] = (
                        Maths::evenlyRandomZeroOne() <= $arguments['probability_is_sourcing']
                    );
                }
                break;

            // Times: randomized.
            case 'mean_ack_time':
            case 'mean_answer_time':
            case 'mean_routing_time':
                $this->data[$argumentName] = Generate::getTime($argumentData);
                break;

            // Positive integers: randomized.
            // Pool size can be zero.
            case 'mean_supplier_pool_size':
                if ($argumentData === 0) {
                    $this->data[$argumentName] = 0;
                    break;
                }
            case 'mean_extra_suppliers':
                // Cut-off at four times the mean i.e. 1-9 suppliers (0-8 extra) peaks at 1 + (9-1)/4 = 3.
                $this->data[$argumentName] = Generate::getNumber($argumentData, $argumentData * 4);
                break;

            // Probabilities: 0, 1 or randomized.
            case 'probability_no_ack':
            case 'probability_no_answer':
            case 'probability_pick_from_pool':
                switch ($argumentData * 1) {
                case 0:
                case 1:
                    $this->data[$argumentName] = $argumentData;
                    break;

                default:
                    $this->data[$argumentName] = Generate::getProbability($argumentData);
                }
            }
        }

        // Ensure data is simple key/value list of scalars.
        $toHide = $this->temporarilyHideData();

        // Call parent method to create this record in the DB.
        parent::create();

        // Save non-scalars.
        $this->insertNormalizedData($toHide);
    }

    /**
     * Overrides ::read().
     *
     * Read entity into $this->data, including tiers from other table.
     *
     * @param int $id
     *   Unique ID of the entity.
     */
    public function read($id)
    {
        parent::read($id);
        if ($this->getID()) {
            $this->retrieveNormalizedData();
        }
    }

    /**
     * Overrides ::update().
     *
     * Update entity while dealing with tiers in other table.
     */
    public function update()
    {
        // Ensure data is simple key/value list of scalars.
        $toHide = $this->temporarilyHideData();

        // Call parent method to update this record in the DB.
        parent::update();

        // Save non-scalars.
        $this->insertNormalizedData($toHide);
    }
    /**
     * Overrides ::delete().
     *
     * Delete entity and also cascade-delete tiers.
     */
    public function delete()
    {
        // Save zero tiers: removes existing ones.
        $this->insertNormalizedData(['tiers' => [], 'supplier_pool' => []]);

        // Call parent method to update this record in the DB.
        parent::delete();
    }

    /**
     * Private function to consistently, temporarily hide non-scalars from ORM.
     *
     * @return array
     *   Array of tier numbers e.g. [1, 2, 3].
     */
    private function temporarilyHideData()
    {
        $toHide = [
            'tiers' => $this->data['tiers'],
            'supplier_pool' => $this->data['supplier_pool'],
        ];
        unset($this->data['tiers']);
        unset($this->data['supplier_pool']);
        return $toHide;
    }

    /**
     * Private function to update tiers in separate table.
     *
     * @param array $data
     *   Array of e.g. ['tier' => [1, 2, 3], 'supplier_pool' => [5]].
     */
    private function insertNormalizedData($data)
    {
        // A "record template", for both bulk deletion and insertion.
        $record = ['entity' => $this->getID()];
        // Clear out table of rows pertaining to this.
        Database::deleteWhere($this->path, 'entity_tier', $record);
        Database::deleteWhere($this->path, 'entity_supplier_pool', $record);

        // Save tiers.
        foreach ($data['tiers'] as $tierId) {
            $record['tier'] = $tierId;
            Database::writeRecord($this->path, 'entity_tier', $record, false);
        }
        // Save supplier pool.
        unset($record['tier']);
        foreach ($data['supplier_pool'] as $supplierId) {
            $record['supplier'] = $supplierId;
            Database::writeRecord($this->path, 'entity_supplier_pool', $record, false);
        }

        // Ensure data is restored on entity.
        $this->data = array_merge($this->data, $data);
    }

    /**
     * Private function to retrieve normalized data into $this->data.
     */
    private function retrieveNormalizedData()
    {
        $this->data['tiers'] = [];
        foreach (Database::getRowsWhere(
            $this->path,
            'entity_tier',
            array("entity" => $this->getID()),
            'tier'
        ) as $row) {
            $this->data['tiers'][] = $row['tier'];
        }

        $this->data['supplier_pool'] = [];
        foreach (Database::getRowsWhere(
            $this->path,
            'entity_supplier_pool',
            array("entity" => $this->getID()),
            'supplier'
        ) as $row) {
            $this->data['supplier_pool'][] = $row['supplier'];
        }
    }

    /**
     * Generate supplier pool based on pool size.
     *
     * Supplier pool is selected by random from all other entities, up to a
     * maximum of the pool size (so it can be smaller). The pool is also
     * filtered by tier: all suppliers must be in this entity's lowest tier
     * plus one (see relevant Bitbucket tickets.)
     */
    public function generateSupplierPool()
    {
        // Make SQL call to get up to N suppliers in the tier one above this
        // entity's lowestmost tier.
        $conn = Database::getConn($this->path);
        $sql = 'SELECT id FROM entity e INNER JOIN entity_tier et ON e.id = et.entity '
            . ' WHERE e.id != :myid AND et.tier = :tier '
            . ' ORDER BY RANDOM() LIMIT :pool';
        $sqlArgs = [
            ':myid' => $this->getID(),
            ':pool' => $this->data['mean_supplier_pool_size'],
            ':tier' => min($this->data['tiers']) + 1,
        ];
        $results = Database::returnStatement($conn, $sql, $sqlArgs)->execute();

        // Store IDs in the supplier pool.
        $this->data['supplier_pool'] = [];
        while ($row = $results->fetchArray(SQLITE3_ASSOC)) {
            $this->data['supplier_pool'][] = $row['id'];
        }

        // Now save the object so its pool persists.
        $this->update();
    }

    /**
     * Get supplier pool, assuming already generated.
     */
    public function getSupplierPool()
    {
        return $this->data['supplier_pool'];
    }
}
